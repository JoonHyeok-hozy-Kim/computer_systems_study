[Back to main](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study#readme)

# 3.12 Out-of-Bounds Memory References and Buffer Overflow

### Prop.) C does not perform any bounds checking for array references. 

### Ex.) String Buffer Overflow example : gets() library function
* C code
  ```c
  char *gets(char *s){
    int c;
    char *dest = s;
    int gotchar = 0;  // Whether at least one char is read or not!
    while ((c = getchar()) != '\n' && c != EOF){
      *dest++ = c;
      gotchar = 1;
    }
    *dest++ = '\0';
    if (c == EOF && !gotchar){
      return NULL;
    }
    return s;
  }

  void echo(){
    char buf[8];  // Very small buffer allocated!
    gets(buf);
    puts(buf);
  }
  ```
* Assembly of the function echo()
  ```assembly
  echo:
    pushl   %ebp              Save %ebp on stack
    movl    %esp, %ebp        
    pushl   %ebx              Save %ebx
    subl    $20, %esp         Allocate 20 bytes on stack
    leal    -12(%ebp), %ebx   Compute buf as %ebp-12
    movl    %ebx, (%esp)      Store buf at top of stack
    call    gets              Call gets()
    movl    %ebx, (%esp)      Store buf at top of stack
    call    puts              Call puts()
    addl    $20, %esp         Deallocate 20 bytes from stack
    popl    %ebx              Restore %ebx
    popl    %ebp              Restore %ebp
    ret                       Return
  ```
* Analysis : How echo() works?
  1. The program stores the contents of registers %ebp and %ebx on the stack.
  2. It allocates an additional 20 bytes by subtracting 20 from the stack pointer.
  3. The location of character array buf is computed as 12 bytes below %ebp (line 6), just below the stored value of %ebx.
  4. As long as the user types at most seven characters, the string returned by gets (including the terminating null) will fit within the space allocated for buf.
     * A longer string, however, will cause gets to overwrite some of the information stored on the stack.
       ![](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/images/03_12_00_stack.png)
* Problem
  * If the allocated buffer is too small, then the out-of-bounds error can occur!
    * As the string gets longer, the following information will get corrupted:
      ![](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/images/03_12_00_table.png)
      1. If the stored value of %ebx is corrupted, then this register will not be restored properly
         * So the caller will not be able to rely on the integrity of this register, even though it should be callee-saved.
      2. If the stored value of %ebp is corrupted, then this register will not be restored properly
         * So the caller will not be able to reference its local variables or parameters properly.
      3. If the stored value of the return address is corrupted, then the ret instruction will cause the program to jump to a totally unexpected location.

### Prop.) Desired not to use gets()
* Following functions also contain gets(), so not suggested for usage.
  * strcpy()
  * strcat()
  * sprintf()


[:orange_book: Practice Problem 3.43](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#-practice-problem-343)









### KEYWORDS
* out-of-bounds error; buffer overflow;


[Back to main](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study#readme)