[Back to main](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study#readme)

# 3.12 Out-of-Bounds Memory References and Buffer Overflow

### Prop.) C does not perform any bounds checking for array references. 

### Ex.) String Buffer Overflow example : gets() library function
* C code
  ```c
  char *gets(char *s){
    int c;
    char *dest = s;
    int gotchar = 0;  // Whether at least one char is read or not!
    while ((c = getchar()) != '\n' && c != EOF){
      *dest++ = c;
      gotchar = 1;
    }
    *dest++ = '\0';
    if (c == EOF && !gotchar){
      return NULL;
    }
    return s;
  }

  void echo(){
    char buf[8];  // Very small buffer allocated!
    gets(buf);
    puts(buf);
  }
  ```
* Assembly of the function echo()
  ```assembly
  echo:
    pushl   %ebp              Save %ebp on stack
    movl    %esp, %ebp        
    pushl   %ebx              Save %ebx
    subl    $20, %esp         Allocate 20 bytes on stack
    leal    -12(%ebp), %ebx   Compute buf as %ebp-12
    movl    %ebx, (%esp)      Store buf at top of stack
    call    gets              Call gets()
    movl    %ebx, (%esp)      Store buf at top of stack
    call    puts              Call puts()
    addl    $20, %esp         Deallocate 20 bytes from stack
    popl    %ebx              Restore %ebx
    popl    %ebp              Restore %ebp
    ret                       Return
  ```
* Analysis : How echo() works?
  1. The program stores the contents of registers %ebp and %ebx on the stack.
  2. It allocates an additional 20 bytes by subtracting 20 from the stack pointer.
  3. The location of character array buf is computed as 12 bytes below %ebp (line 6), just below the stored value of %ebx.
  4. As long as the user types at most seven characters, the string returned by gets (including the terminating null) will fit within the space allocated for buf.
     * A longer string, however, will cause gets to overwrite some of the information stored on the stack.
       ![](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/images/03_12_00_stack.png)
* Problem
  * If the allocated buffer is too small, then the out-of-bounds error can occur!
    * As the string gets longer, the following information will get corrupted:
      ![](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/images/03_12_00_table.png)
      1. If the stored value of %ebx is corrupted, then this register will not be restored properly
         * So the caller will not be able to rely on the integrity of this register, even though it should be callee-saved.
      2. If the stored value of %ebp is corrupted, then this register will not be restored properly
         * So the caller will not be able to reference its local variables or parameters properly.
      3. If the stored value of the return address is corrupted, then the ret instruction will cause the program to jump to a totally unexpected location.

### Prop.) Desired not to use gets()
* Following functions also contain gets(), so not suggested for usage.
  * strcpy()
  * strcat()
  * sprintf()


[:orange_book: Practice Problem 3.43](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#-practice-problem-343)


### Concept) Buffer Overflow Attack
* Def.) Exploiting buffer overflow to perform a function that it would otherwise be unwilling to
* ex)
  * A program that is fed with a string that contains the byte encoding of some executable code (AKA exploit code)


---


## 3.12.1 Thwarting Buffer Overflow Attacks

### Tech.) How to defend
1. [Stack Randomization](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/12.md#concept-stack-randomization)
2. [Stack Corruption Detection](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/12.md#concept-stack-corruption-detection)
3. [Limiting Executable Code Regions](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/12.md#concept-limiting-executable-code-regions)


### How to 1) Stack Randomization
* Goal) Make the position of the stack vary from one run of a program to another.
  * why doing this?
    * In the past days, for all systems running the same combination of program and operating system version, the stack locations were fairly stable across many machines.
    * Thus, the stack addresses for a program were highly predictable.
    * Hence, the attacker easily figured out the stack address where the attack string will be located.
    * Therefore, the attacker used this address to generate the executable exploit code.
* How?)
  * Allocate a random amount of space between 0 and n bytes on the stack at the start of a program
    * ex.) For Linux, use the function *alloca* to allocate space for a specified number of bytes on the stack.
  * This allocated space is not used by the program.
* Prop.)
  * The allocation range *n* needs to be large enough to get sufficient variation in the stack address
  * The allocation range *n* needs to be small enough that it does not waste too much space in the program.
#### Application) Linux, Address-Space Layout Randomization (ASLR)
* With ASLR, distinctive parts of the program including, program code, library code, stack, global variables, and heap data, are loaded into different regions of memory each time a program is run.
#### Counter Attack) nop sled
* Desc.)
  * The attacker include a long sequence of "no operation instructions(nop)" before the actual exploit code.
  * nop instructions only increment the program counter and does not affect the program.
    * Using the brute-force method, the attacker is guessing the address of the stack!
    * Thus, there is no complete safe guard for this attack.
  * As long as the attacker can guess an address somewhere within this sequence, the program will run through the sequence and then hit the exploit code.


[:orange_book: Practice Problem 3.44](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#-practice-problem-344)



### How to 2) Stack Corruption Detection


### How to 3) Limiting Executable Code Regions



### KEYWORDS
* out-of-bounds error; buffer overflow; buffer overflow attack; exploit code; stack randomization; security monoculture; address-space layout randomization(ASLR); nop sled; 


[Back to main](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study#readme)