[Back to main](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study#readme)

# 3.6 Control

## 3.6.1 Conditional Codes
### Concept) Condition Code
* Def.) A set of single-bit condition code registers describing attributes of the most recent arithmetic or logical operation.
* Props.)
  * Maintained by the CPU
* Types
  1. **CF (Carry Flag)**
     * Desc.) The most recent operation generated a  carry out of the most significant bit. Used to  detect overflow for unsigned operations.
     * Prop.) Matters only if UNSIGNED
     * ex)
       * 1111 + 1000 = 0111 → CF = 1
       * 0000 - 0001 = 1111 → CF = 1
  2. **ZF (Zero Flag)**
     * Desc. : The most recent operation yielded zero.
  3. **SF (Sign Flag)**
     * Desc. : The most recent operation yielded a negative value.
  4. **OF (Overflow Flag)**
     * Desc. : The most recent operation caused a  two’s-complement overflow—either negative or  positive.
     * Prop.) Matters only if TWO'S COMPLEMENT
     * ex)
       * 0111 + 0001 = 1000 → OF = 1 (why? POS + POS  = NEG)
       * 1000 + 1101 = 0101 → OF = 1 (why? NEG + NEG  = POS)

<br>

### Prop.) All instructions [HERE](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/05.md#concept-4-groups-of-operations) except leal cause the condition codes to be set.
* ex.) XOR
  * CF and OF are set to 0.
* ex.) shift operations (SAL, SHL, SAR, SHR)
  * CF is set to the last bit shifted out
  * OF is set to 0.
* ex.) INC / DEC
  * OF and ZF are set but leave CF unchanged

<br>

### Concept) Comparison and Test Instructions (CMP / TEST)

<p align="left">
  <img src="https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/images/03_06_01_cmp_test.png" width="60%">
</p>

* Prop.) CMP and TEST instructions set condition codes without altering any other registers.
#### Concept) **CMP Instructions**
  * They behave in the same way as the sub instructions, except that they set the condition codes without updating their destinations.
  * They set the zero flag (ZF) if the two operands are equal.
  * The other flags can be used to determine ordering relations between the two operands.
#### Concept) **TEST Instructions**
  * They behave in the same manner as the and instructions, except that they set the condition codes without altering their destinations.
  * Typically, the same operand is repeated 
    * e.g.) "testl %eax, %eax" to see whether %eax is negative, zero, or positive
      * ex) Usage with [JUMP]() instruction
        * In C language
          ```c
          int dw_loop(int x, int n){
            do {
              x += n;
              n--;
            } while (n > 0);
            return x;
          }
          ```
        * In assembly
          ```assembly
            movl  8(%ebp), %eax
            movl  16(%ebp), %edx
          .L2:
            addl  %edx, %eax
            subl  $1, %edx
            testl %edx, %edx
            jg .L2
          ```
  * One of the operands is a mask indicating which bits should be tested.   
   
<br>
   
---

## 3.6.2 Accessing the Condition Codes

### Concept) Three Common Ways of Using the Condition Codes
1. We can [SET](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/06.md#concept-set-instructions) a single byte to 0 or 1 depending on some combination of the condition codes.
2. We can conditionally [JUMP](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/06.md#363-jump-instructions-and-their-encodings) to some other part of the program.
3. We can conditionally transfer data.


### Concept) SET Instructions
* Def.) Set a single byte to 0 or to 1 depending on some combination of the condition codes.
* Types
  ![](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/images/03_06_02_set_instructions.png)
* Props.)
  * Suffixes denote different conditions and NOT different operand sizes.
  * Destinations : either [one of the eight single-byte register elements](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/04.md#concept-8-registers-in-an-ia32-cpu) or a single-byte memory location
  * Result : Set the destination bytes to either 0 or 1.
    * Thus, to generate a 32-bit result, we must also clear the high-order 24 bits.
      * How
        ```assembly
        cmpl   %eax, %edx
        setl   %al
        movzbl %al, %eax
        ```


#### Concept) Synonyms
* Def.) multiple possible names
* ex.) setg (set greater) <==> setnle (set not less or equal to)
* Prop.) Compilers and disassemblers make arbitrary choices of which names to use.
* Prop.) Use "t = a-b" condition.
  * ex.) sete instruction
    * "a equals b." <==> "t equals 0."
    * Thus, synonym : setz

<br><br>

#### Tech.) Use "t = a-b" to understand the flag determinations
* ex1.) **sete**
  * "a = b" <==> "t = 0"
  * Thus, "ZF = 1"
* ex2.) **setl** (Only for signed!)
  * "a < b" <==> "a-b < 0" <==> "t < 0"
  * Consider the following cases that satisfy "**a < b**"
    1. No overflow (OF = 0)
       * Then, obviously "a < b" → "a-b **< 0**" → SF = 1 (sign flag!)
       * i.e.) OF = 0 / SF = 1
    2. Positive overflow (OF = 1)
       * Then, "a-b > 0" → SF = 0 (The sign of a-b is non-negative.)
         * ex.) 0111 - 1000 = 0111 + 1000 = 1111 > 0
       * i.e.) OF = 1 / SF = 0
    3. Negative overflow (OF = 1)
       * Impossible.
         * why?) Negative overflow takes place only if a < 0 and b > 0 → a > b (x)
  * Thus, by 1 and 2, **SF^OF = 1**
* ex2.) **setb** (Only for unsigned!)
  * "a < b" <==> "a-b < 0" <==> "t < 0"
  * Since a and b are unsigned numbers, if a < b, then there will be CARRY!
    * ex.) 0001 - 0011 = 0001 + 1101 = **1**110
  * Thus, **CF = 1**


[:orange_book: Practice Problem 3.13](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-313)

[:orange_book: Practice Problem 3.14](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-314)

---

## 3.6.3 Jump Instructions and Their Encodings
### Concept) Jump Instruction
* Def.) An instruction that cause the execution to switch to a completely new position in the program.
* Term.) Label : an assembly code that indicates the jump destination
  * ex.) .L1 in the following code.
    ```assembly
      movl $0, %eax
      jmp  .L1
      movl (%eax), %edx
    .L1:
      popl %edx
    ```
* Types
  ![](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/images/03_06_03_jump_instructions.png)

#### Props.) jmp instructions are unconditional, while others are conditional.
#### Props.) Direct Jump vs Indirect Jump
1. Direct Jump : Jump target is encoded as part of the instruction.
  ```assembly
  jmp .L1
  ```
1. Indirect Jump : The jump target is read from a register or a memory location.
  * Use the value in register %eax as the jump target
    ```assembly
    jmp *%eax
    ```
  * Reads the jump target from memory, using the value in %eax as the read address.
    ```assembly
    jmp *(%eax)
    ```
#### Props.) Conditional Jump Instructions can only be direct.

<br><br>

### Concept) Encodings for Jumps : PC relative vs Giving Absolute Address
#### Concept) PC Relative (Program Counter Relative)
* Def.) Encoding the difference between the address of the target instruction and the address of the instruction immediately following the jump.
* Prop.) 
  * Offsets can be encoded using 1, 2, or 4 bytes.
  * Note that the value of the program counter when performing PC-relative addressing is **the address of the instruction following the jump**, not that of the jump itself.
    * 0xa and 0x17 in the following example!
* Ex.) Consider the following assembly code
  ```assembly
    jle   .L2
  .L5:
    movl  %edx, %eax
    sarl  %eax
    subl  %eax, %edx
    leal  (%edx, %edx, 2), %edx
    testl %edx, %edx
    jg    .L5
  .L2:
    movl  %edx, %eax
  ```
  * Suppose the disassembled version of the object file is generated by the assembler as follows :
    ![](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/images/03_06_03_pc_relative_ex.png)
    * cf.) Disassembled version of the program after linking.
      ![](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/images/03_06_03_pc_relative_after_linking.png)

#### Concept) Giving Absolute Address
  * Def.) Using 4 bytes to directly specify the target.

[:orange_book: Practice Problem 3.15](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-315)

---

## 3.6.4 Translating Conditional Branches
### Concept) goto code
* Def.) A way to construct C programs that describe the control flow of assembly-code programs, using *goto* statement.
* ex.)
  ```c
  int gotodiff(int x, int y){
    int result;
    if (x >= y){
      goto x_ge_y;
      result = y - x;
      goto done;
    x_ge_y:
      result = x - y;
    done:
      return result;
    }
  }
  ```
* Prop.)
  * Generally considered a bad programming style, due to its difficulty in reading and debugging.


#### Tech.) Representing C's "if-else" statement with goto-code.
```c
t = test_expr;
if (!t){
  goto false;
  // then_statement;
  goto done;
false:
  // else_statement;
done:
  return;
}
```


[:orange_book: Practice Problem 3.16](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-316)

[:orange_book: Practice Problem 3.17](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-317)

[:orange_book: Practice Problem 3.18](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-318)

---

## 3.6.5 Loops

* Types
  * [Do-While Loops](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/06.md#concept-do-while-loops)
  * [While Loops](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/06.md#concept-while-loops)
  * [For Loops](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/06.md#concept-for-loops)


### Concept) Do-While Loops
#### Prop.) General form of do-while statement
```
do 
  body-statement
  while (test-expr);
```

#### Tech.) Translation to goto code
```
loop:
  body-statement
  t = test-expr;
  if (t)
    goto loop;
```

#### Ex.) Factorial Implementation
* In C language
  ```c
  int fact_do(int n){
    int result = 1;
    do {
      result *= n;
      n--;
    } while (n > 1);
    return result;
  }
* In assembly
  ```assembly
    movl  8(%ebp), %edx
    movl  $1, %eax
  .L2:
    imull %edx, %eax
    subl  $1, %edx
    cmpl  $1, %edx
    jg    .L2
  ```


[:orange_book: Practice Problem 3.19](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-319)


[:orange_book: Practice Problem 3.20](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-320)


### Concept) While Loops
#### Prop.) General form of while statement
```
while (test-expr)
  body-statement
```

#### Tech.) Translation to goto code
```
t = test-expr;
if (!t)
  goto done;
loop:
  body-statement
  t = test-expr;
  if (t)
    goto loop;
done:
```

#### Ex.) Factorial Implementation
* In C language
  ```c
  int fact_while(int n){
    int result = 1;
    while (n > 1){
      result *= n;
      n--;
    }
    return result;
  }
  ```
* In goto code with C
  ```c
  int fact_goto(int n){
    int result = 1;
    if (n < 2){
      goto done;
    }
    loop:
      result *= n;
      n--;
      if (n > 1){
        goto loop;
      }
    done:
      return result;
  }
  ```
* In assembly
  ```assembly
    movl  8(%ebp), %edx
    movl  $1, %eax
    cmpl  $2, %edx
    jl    .L5
  .L2:
    imull %edx, %eax
    subl  $1, %edx
    cmpl  $2, %edx
    jge   .L2
  .L5:
  ```

[:orange_book: Practice Problem 3.21](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-321)

[:orange_book: Practice Problem 3.22](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-322)


### Concept) For Loops
#### Prop.) General form of for loop
```
for (init-expr; test-expr; update-expr)
  body-statement
```

#### Tech.) Translation to goto code
```
init-expr;
t = test-expr;
if (!t)
  goto done;
loop:
  body-statement
  update-expr;
  t = test-expr;
  if (t):
  goto loop;
done:
```

#### Ex.) Factorial Implementation
* In C language
  ```c
  int fact_for(int n){
    int result = 1;
    int i;

    for (i=2; i<=n; i++){
      result *= i;
    }

    return result;
  }
  ```
* In C goto code
  ```c
  int fact_for_goto(int n){
    int result = 1;
    int i;
    if (n < 2){
      goto done;
    }
    i = 1;
    loop:
      result *= i;   
      i++;   
      if (i <= n){
        goto loop;
      }
    done:
      return result;
  }
  ```
* In assembly
  ```assembly
  movl  8(%ebp), %edx
  movl  $1, %eax
  cmpl  $2, %edx
  jl    .L5
  movl  $1, %ecx
  .L3:
    addl  $1, %ecx
    imull %ecx, %eax
    cmpl  %edx, %ecx
    jl    .L3
  .L5:
  ```

[:orange_book: Practice Problem 3.23](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-323)





### KEYWORDS
* condition code; carry flag; zero flag; sign flag; overflow flag; comparison instructions (CMP); test instructions (TEST); SET Instructions; jump instruction; label; direct jump; indirect jump; encodings for jump; PC relative (Program Counter Relative); goto code; do-while loop; 


[Back to main](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study#readme)