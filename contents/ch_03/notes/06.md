[Back to main](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study#readme)

# 3.6 Control

## 3.6.1 Conditional Codes
### Concept) Condition Code
* Def.) A set of single-bit condition code registers describing attributes of the most recent arithmetic or logical operation.
* Props.)
  * Maintained by the CPU
* Types
  1. **CF (Carry Flag)**
     * Desc.) The most recent operation generated a  carry out of the most significant bit. Used to  detect overflow for unsigned operations.
     * Prop.) Matters only if UNSIGNED
     * ex)
       * 1111 + 1000 = 0111 → CF = 1
       * 0000 - 0001 = 1111 → CF = 1
  2. **ZF (Zero Flag)**
     * Desc. : The most recent operation yielded zero.
  3. **SF (Sign Flag)**
     * Desc. : The most recent operation yielded a negative value.
  4. **OF (Overflow Flag)**
     * Desc. : The most recent operation caused a  two’s-complement overflow—either negative or  positive.
     * Prop.) Matters only if TWO'S COMPLEMENT
     * ex)
       * 0111 + 0001 = 1000 → OF = 1 (why? POS + POS  = NEG)
       * 1000 + 1101 = 0101 → OF = 1 (why? NEG + NEG  = POS)

<br>

### Prop.) All instructions [HERE](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/05.md#concept-4-groups-of-operations) except leal cause the condition codes to be set.
* ex.) XOR
  * CF and OF are set to 0.
* ex.) shift operations (SAL, SHL, SAR, SHR)
  * CF is set to the last bit shifted out
  * OF is set to 0.
* ex.) INC / DEC
  * OF and ZF are set but leave CF unchanged

<br>

### Concept) Comparison and Test Instructions (CMP / TEST)

<p align="left">
  <img src="https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/images/03_06_01_cmp_test.png" width="60%">
</p>

* Prop.) CMP and TEST instructions set condition codes without altering any other registers.
#### Concept) **CMP Instructions**
  * They behave in the same way as the sub instructions, except that they set the condition codes without updating their destinations.
  * They set the zero flag (ZF) if the two operands are equal.
  * The other flags can be used to determine ordering relations between the two operands.
#### Concept) **TEST Instructions**
  * They behave in the same manner as the and instructions, except that they set the condition codes without altering their destinations.
  * Typically, the same operand is repeated 
    * e.g.) "testl %eax, %eax" to see whether %eax is negative, zero, or positive
  * One of the operands is a mask indicating which bits should be tested.   
   
<br>


## 3.6.2 Accessing the Condition Codes

### Concept) Three Common Ways of Using the Condition Codes
1. We can [SET](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/06.md#concept-set-instructions) a single byte to 0 or 1 depending on some combination of the condition codes.
2. We can conditionally [JUMP]() to some other part of the program.
3. We can conditionally transfer data.


### Concept) SET Instructions
* Def.) Set a single byte to 0 or to 1 depending on some combination of the condition codes.
* Types
  ![](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/images/03_06_02_set_instructions.png)
* Props.)
  * Suffixes denote different conditions and NOT different operand sizes.
  * Destinations : either [one of the eight single-byte register elements](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/notes/04.md#concept-8-registers-in-an-ia32-cpu) or a single-byte memory location
  * Result : Set the destination bytes to either 0 or 1.
    * Thus, to generate a 32-bit result, we must also clear the high-order 24 bits.
      * How
        ```assembly
        cmpl   %eax, %edx
        setl   %al
        movzbl %al, %eax
        ```


#### Concept) Synonyms
* Def.) multiple possible names
* ex.) setg (set greater) <==> setnle (set not less or equal to)
* Prop.) Compilers and disassemblers make arbitrary choices of which names to use.
* Prop.) Use "t = a-b" condition.
  * ex.) sete instruction
    * "a equals b." <==> "t equals 0."
    * Thus, synonym : setz


#### Tech.) Use "t = a-b" to understand the flag determinations
* ex1.) **sete**
  * "a = b" <==> "t = 0"
  * Thus, "ZF = 1"
* ex2.) **setl** (Only for signed!)
  * "a < b" <==> "a-b < 0" <==> "t < 0"
  * Consider the following cases that satisfy "**a < b**"
    1. No overflow (OF = 0)
       * Then, obviously "a < b" → "a-b **< 0**" → SF = 1 (sign flag!)
       * i.e.) OF = 0 / SF = 1
    2. Positive overflow (OF = 1)
       * Then, "a-b > 0" → SF = 0 (The sign of a-b is non-negative.)
         * ex.) 0111 - 1000 = 0111 + 1000 = 1111 > 0
       * i.e.) OF = 1 / SF = 0
    3. Negative overflow (OF = 1)
       * Impossible.
         * why?) Negative overflow takes place only if a < 0 and b > 0 → a > b (x)
  * Thus, by 1 and 2, **SF^OF = 1**
* ex2.) **setb** (Only for unsigned!)
  * "a < b" <==> "a-b < 0" <==> "t < 0"
  * Since a and b are unsigned numbers, if a < b, then there will be CARRY!
    * ex.) 0001 - 0011 = 0001 + 1101 = **1**110
  * Thus, **CF = 1**


[:orange_book: Practice Problem 3.13](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study/blob/main/contents/ch_03/problems/practice_problems.md#practice-problem-313)




### KEYWORDS
* condition code; carry flag; zero flag; sign flag; overflow flag; comparison instructions (CMP); test instructions (TEST); SET Instructions;


[Back to main](https://github.com/JoonHyeok-hozy-Kim/computer_systems_study#readme)